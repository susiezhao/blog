{"data":{"site":{"siteMetadata":{"title":"Blog","author":"susiezhao"}},"markdownRemark":{"id":"a9526b66-727d-57e0-989a-b5cfe357a308","excerpt":"基于数据劫持的双向数据绑定 常见的基于数据劫持的双向数据绑定的实现方式：ES5提供的   和ES6提供的   。基于数据劫持的双向数据绑定的优势在于：1、无需显示调用；2、可精确得知变化数据。 Object.defineProperty…","html":"<h1>基于数据劫持的双向数据绑定</h1>\n<p>常见的基于数据劫持的双向数据绑定的实现方式：ES5提供的 <code class=\"language-text\">Object.defineProperty</code> 和ES6提供的 <code class=\"language-text\">Proxy</code> 。基于数据劫持的双向数据绑定的优势在于：1、无需显示调用；2、可精确得知变化数据。</p>\n<h2>Object.defineProperty</h2>\n<p><code class=\"language-text\">Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。<br>\n用法：<code class=\"language-text\">Object.defineProperty(obj, prop, descriptor)</code></p>\n<ul>\n<li><code class=\"language-text\">obj</code>: 要在其上定义属性的对象 </li>\n<li><code class=\"language-text\">prop</code>: 要定义或修改的属性名称</li>\n<li><code class=\"language-text\">descriptor</code>: 将被定义或修改的属性描述符</li>\n</ul>\n<h3>属性描述符</h3>\n<p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的也可能是不可写的；存取描述符是由getter-setter函数对描述的属性。<code class=\"language-text\">descriptor</code> 必须是这两种形式之一，不能同时是两者。</p>\n<p>数据描述符和存取描述符公有的属性：</p>\n<ul>\n<li><code class=\"language-text\">configurable</code>: 当且仅当该属性值为true时，该属性描述符才能够被修改，同时该属性也能从对应的对象上被删除。默认值为false；在对象上直接定义的属性，该特性默认值为true；</li>\n<li><code class=\"language-text\">enumerable</code>: 当且仅当该属性值为true时，该属性才能出现在对象的枚举属性中。默认值为false；在对象上直接定义的属性，该特性默认值为true；</li>\n</ul>\n<p>数据描述符独有的属性：</p>\n<ul>\n<li><code class=\"language-text\">writable</code>: 当且仅当该属性值为true时，<code class=\"language-text\">value</code> 才能被赋值运算符修改。默认值为false；在对象上直接定义的属性，该特性默认值为true；</li>\n<li><code class=\"language-text\">value</code>: 该属性对应的值。默认值为undefined；</li>\n</ul>\n<p>存取描述符独有的属性：</p>\n<ul>\n<li><code class=\"language-text\">get</code>: 给属性提供 getter 方法，在读取属性时调用的方法。默认值为undefined；</li>\n<li><code class=\"language-text\">set</code>: 给属性提供 setter 方法，在写入属性时调用的函数。默认值为undefined</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>调用 <code class=\"language-text\">Object.defineProperty()</code> 方法创建一个新属性时，如果不指定，则 <code class=\"language-text\">configurable</code> <code class=\"language-text\">writable</code> <code class=\"language-text\">enumerable</code> 特性的默认值都是 false。</li>\n<li>当试图改变不可配置属性（除了<code class=\"language-text\">value</code> 和 <code class=\"language-text\">writable</code> 属性之外，且 <code class=\"language-text\">writable</code> 属性值只能改为 false ）的值时会抛出TypeError。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = {\n    a: 1,\n    get d() {\n        return this.a;\n    },\n    set d(value) {\n        this.a = value;\n    }\n};\nObject.defineProperty(obj, &#39;b&#39;, {});\nObject.defineProperty(obj, &#39;c&#39;, {\n    get: function() {\n        console.log(&#39;getter:&#39;);\n        return this.a;\n    },\n    set: function(value) {\n        console.log(&#39;setter&#39;);\n        this.a = value;\n    }\n});\nvar descriptor_a = Object.getOwnPropertyDescriptor(obj, &#39;a&#39;); // { value: 1, configurable: true, enumerable: true, writable: true }\nvar descriptor_b = Object.getOwnPropertyDescriptor(obj, &#39;b&#39;); // { value: undefined, configurable: false, enumerable: false, writable: false }\nvar descriptor_c = Object.getOwnPropertyDescriptor(obj, &#39;c&#39;); // { configurable: false, enumerable: false, get: f, set: f }\nvar descriptor_d = Object.getOwnPropertyDescriptor(obj, &#39;c&#39;); // { configurable: true, enumerable: true, get: f, set: f }</code></pre></div>\n<h3>数据劫持</h3>\n<p><code class=\"language-text\">Object.defineProperty()</code> 主要利用存取属性描述符中的 <code class=\"language-text\">get</code> 和 <code class=\"language-text\">set</code> 属性来实现劫持一个对象的属性，在对象属性发生变化时进行特定的操作。数据劫持的应用例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Observer(obj, callback) {\n  var observe = function(obj, path) {\n    let type = Object.prototype.toString.call(obj);\n    // Object 类型\n    if (type === &#39;[object Object]&#39; || type === &#39;[object Array]&#39;) {\n      observeObject(obj, path);\n      if (type === &#39;[object Array]&#39;) {\n        observeArrayPreparation(obj, path);\n      }\n    }\n  };\n\n  var observeObject = function(obj, path) {\n    // for...in 可以遍历对象实力属性和原型属性\n    for (let prop in obj)  {\n      let value = obj[prop];\n      let _path = path.slice();\n      _path.push(prop);\n      Object.defineProperty(obj, prop, {\n        get: function() {\n          return value;\n        },\n        set: function(newValue) {\n          if (value === newValue) {\n            return;\n          }\n          callback(_path, newValue, value);\n          value = newValue;\n        }\n      });\n      // 递归\n      observe(value, _path);\n    } \n  };\n\n  var observeArrayPreparation = function(arr, path) {\n    var _props = [&#39;push&#39;, &#39;pop&#39;, &#39;unshift&#39;, &#39;shift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;]; // 改变原数组的操作\n    var _newProto = Object.create(Array.prototype);\n    _props.forEach((prop) =&gt; {\n      Object.defineProperty(_newProto, prop, {\n        value: function() {\n          var _path = path.slice();\n          _path.push(prop);\n          callback(_path);\n          Array.prototype[prop].apply(arr, arguments);\n        }\n      });\n    });\n    arr.__proto__ = _newProto;\n  };\n\n  observe(obj, []);\n}\n\nvar obj1 = {\n  a: 1,\n  b: 2,\n  c: {\n    d: 3,\n    e: 4,\n  },\n};\n\nvar obj2 = {\n  a: 1,\n  b: 2,\n  c: [3, 4],\n};\n\nnew Observer(obj1, (path, newVle, oldVle) =&gt; {\n  console.log(`path: ${path}, newValue: ${newVle}, oldValue: ${oldVle}`)\n});\n\nnew Observer(obj2, (path, newVle, oldVle) =&gt; {\n  console.log(`path: ${path}, newValue: ${newVle}, oldValue: ${oldVle}`)\n});</code></pre></div>\n<p><code class=\"language-text\">Object.defineProperty()</code> 用作数据劫持时存在如下缺陷：</p>\n<ul>\n<li>监听情况只限于对象属性的修改，如果对对象属性的增删，此时不是进行数据劫持；</li>\n<li>该方法本身无法对数组对象进行监听，通过上述自定义数组对象进行处理后，数组中新增加的元素的修改仍然无法监听；</li>\n</ul>\n<h2>Proxy</h2>\n<p>ES6提供了Proxy构造函数，用来生成一个Proxy实例。其在目标对象之前架设一层拦截，外界对该对象的访问，都必须通过这层拦截，因此Proxy提供了一种机制，可以对外界的访问进行过滤和改写。Proxy可以使用 <code class=\"language-text\">get</code> 和 <code class=\"language-text\">set</code> 来拦截对象属性的访问，<code class=\"language-text\">apply</code> 拦截函数的调用等多达13中拦截操作。<br>\n用法：<code class=\"language-text\">var proxy = new Proxy(target, handler);</code></p>\n<ul>\n<li><code class=\"language-text\">target</code>: 表示所要拦截的目标对象，可以是JavaScript 中任何合法的对象；</li>\n<li><code class=\"language-text\">handler</code>: handler参数也是一个对象，用来定制拦截行为；</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = new Proxy({}, {\n  get: function (target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function (target, key, value, receiver) {\n    console.log(`setting ${key}!`);\n    return Reflect.set(target, key, value, receiver);\n  }\n});\n\nobj.count = 1; // setting count!\n++obj.count;\n// getting count!\n// setting count!\n// 2</code></pre></div>\n<h3>数据劫持</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/* maps observable propertires to a Set of observer functions, which use the property */\nvar observers = new WeakMap();\n\n// contains the triggered observer functions, which should run soon\nvar queuedObservers = new Set();\n\n// points to the currently running observer function, can be undefined\nvar currentObserver;\n\n/*\n*transforms an object into an observable by wrapping it into a proxy,\n* it also adds a blank Map for property-observer pairs to be saved later\n*/\nfunction observable(obj) {\n  observers.set(obj, new Map());\n  return new Proxy(obj, { get, set });\n}\n\n// the exposed observe function, which defined which property of the object to be observed\nfunction observe(fn) {\n  queueObserver(fn);\n}\n\nfunction get(target, key, receiver) {\n  const result = Reflect.get(target, key, receiver);\n  if (currentObserver) {\n    registerObserver(target, key, currentObserver);\n    if (typeof result === &#39;object&#39;) {\n      const observableResult = observable(result);\n      Reflect.set(target, key, observableResult, receiver);\n      return observableResult;\n    }\n  }\n  return result;\n}\n\nfunction registerObserver(target, key, observer) {\n  let observersForKey = observers.get(target).get(key);\n  if (!observersForKey) {\n    observersForKey = new Set();\n    observers.get(target).set(key, observersForKey);\n  }\n  observersForKey.add(observer);\n}\n\nfunction set(target, key, value, receiver) {\n  const observersForKey = observers.get(target).get(key);\n  if (observersForKey) {\n    observersForKey.forEach(queueObserver);\n  }\n  return Reflect.set(target, key, value, receiver);\n}\n\n/*\n*Queued observers run asynchronously in one batch, which results in superior performance. During *registration, the observers are synchronously added to the queuedObservers Set. A Set cannot contain *duplicates, so enqueuing the same observer multiple times won&#39;t result in multiple executions.\n*/\nfunction queueObserver(observer) {\n  if (queuedObservers.size === 0) {\n    Promise.resolve().then(runObservers);\n  }\n  queuedObservers.add(observer);\n}\n// execute the observe functions in batch\nfunction runObservers() {\n  try {\n    queuedObservers.forEach((observer) =&gt; {\n      currentObserver = observer;\n      observer();\n    });\n  } finally {\n    currentObserver = undefined;\n    queuedObservers.clear();\n  }\n}\n\n// Test example\nvar obj = {\n  a: 1,\n  b: {\n    c: 1,\n    d: [1, 2],\n  },\n  e: [1, 2, 3]\n};\nvar proxy = observable(obj);\nfunction print() {\n  console.log(`监听属性发生变化:\\n a: ${proxy.a}\\n b: b.c:${proxy.b.c}, b.d:${proxy.b.d}\\n e: ${proxy.e}`, );\n}\n\nobserve(print);</code></pre></div>\n<h1>优点 &#x26;&#x26; 缺点</h1>\n<p>优点：Proxy 用于数据劫持是支持对象的扩展属性的数据劫持，因为 Proxy 是按照单个对象定义数据劫持的，所以对象动态添加的属性可以被数据劫持；而 ES5 提供的 Object。defineProperty 在进行数据劫持时是不支持扩展属性的劫持的，其每个属性的 get 和 set 的拦截操作都是必须预先定义才能实现拦截。例如 Object.defineProperty 对于数组的数据劫持必须通过重定义数组的方法才能实现，其本身是无法直接支持数组的劫持的；而 Proxy 本身直接支持数组的劫持；  </p>\n<p>缺点: Proxy 的浏览器的支持不全，且不能通过 polyfill 实现；而 Object.defineProperty 的浏览器支持性很好，基本上主流的浏览器全部实现支持了。</p>","frontmatter":{"title":"Proxy VS Object.defineProperty","date":"April 06, 2019","description":"对比基于 Proxy 和 Object.defineProperty 的数据劫持."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/data-binding/proxy_Object.definedProperty/","previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World"}},"next":null}}